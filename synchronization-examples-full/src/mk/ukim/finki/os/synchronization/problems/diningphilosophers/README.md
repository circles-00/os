Начин за тестирање решенија на проблемот „Филозофи кои вечераат“
=============================================================================

1. Опис на проблемот
--------------------

N филозофи седат на кружна маса. Пред секој филозоф се наоѓа порција тестенини, а помеѓу секоја порција се наоѓа по една вилушка. Секој филозоф го поминува времето во јадење и размислување. За филозофот да може да почне да јаде, потребно е да ги држи обете вилушки кои се наоѓаат до неговата порција, што значи дека два соседни филозофи не можат да јадат истовремено бидејќи при тоа би користеле иста вилушка. Може да се смета дека проциите не се трошат, т.е. овозможуваат бесконечен број оброци. За конзумирање еден оброк на филозофот му е потребно конечно време, по што истиот почнува да размислува за по некое време повторно да сака да јаде.

Потребно е да се пронајде алгоритам кој ја максимизира истовременоста на јадењето на филозофите и не дозволува филозоф да изгладнува.

2. Решение на проблемот
-----------------------

Одбрано е едно<sup>1</sup> од предложените решенија на Edsger W. Dijkstra именувано „Resource hierarchy solution“<sup>2</sup>, т.е. решение со формирање хиерархија на ресурси. Алгоритмот нуди сигурност дека нема да се случи блокада или изгладнување.

Се врши подредување на вилушките со користење на правилото: секој филозоф се обидува да ја земе вилушката со помал реден број, а откако ќе ја добие, се обидува да ја земе вилушката со поголем реден број.

Коректноста на решението може да се согледа преку пример. Нека N = 5 – пет филозофи, пет порции и пет вилушки. Филозофите и вилушките се означуваат со броеви од 1 до 5 така што вилушката 1 се наоѓа оддесно на филозофот 1. Нека сите филозофи почнат да јадат одеднаш. Филозофот 1 ја зема вилушката 1 и чека да ја добие вилушката 2 која истовремено ја земал филозофот 2. Вториот филозоф чека да ја добие вилушката 3 која веќе ја земал филозофот 3, кој чека да ја добие четвртата вилушка земена од филозофот 4. Поради подредувањето на вилушките, филозофот 5 нема да посегне по вилушката 5 бидејќи најпрво му е потребна вилушката 1, што придонесува истиот да чека првиот филозоф да заврши со оброкот и да ја остави потребната вилушка. Филозофот 4 може да ја земе вилушката 5 и веднаш да почне со оброкот, а откако ќе заврши, да ги остави двете вилушки на масата, со што филозофот 3 ќе може веднаш да почне да јаде. На истиот начин, филозофите означени со броевите 3, 2 и 1 ќе завршат со оброкот, а по тоа филозофот 5 ќе може да ја добие вилушката 1, а потоа и вилушката 5.

Повеќе информации можат да се најдат во статиите 1 и 2 наведени во секцијата „Користени извори“.

Забелешка: не се користи решението на Andrew S. Tanenbaum<sup>3</sup> бидејќи допушта изгладнување.

3. Начин за тестирање решенија
-----------------------------------

Приложени се два .java документи: `DiningPhilosophers.java` и `DiningPhilosophersState.java`.

**DiningPhilosophers.java**

Класата `DiningPhilosophers` дефинира класа `Philosopher` која претставува филозоф и го имплементира претходно опишаното решение. Класата содржи референци кон вилушките, кои на истиот му се доделени согласно со решението. Пред да започне да јаде, филозофот чека да ја добие вилушката со помал реден број, а потоа онаа со поголем. Откако ќе заврши со оброкот и ќе ги остави вилушките, тој почнува да размислува.

`DiningPhilosophers` класата содржи N семафори кои ги претставуваат вилушките на масата. Секој семафор е поддесен да пропушта само една нишка -  една вилушка истовремено може да ја користи само еден филозоф. `main()` методот го повикува `run()` методот само еднаш – доколку има потреба од повеќекратно извршување на методот, истото може да се симулира со промена на вредноста на една од следните променливи:

- `DiningPhilosophers.NUMBER_OF_PHILOSOPHERS` - број на филозофи.
- `numRuns` - број на извршувања на `execute()` методот на секој филозоф.
- `numIterations` - број на извршувања на решението, т.е. севкупниот број на маси на кои седат филозофи.
- `step` - вредноста на зголемувањето на бројот на филозофи на масата во секоја наредна итерација.

**DiningPhilosophersState.java**

Оваа класа овозможува тестирање на валидноста на решението. Ниту еден од следните настани не смее да се случи при извршување коректно решение:

1. Една вилушка се користи истовремено од повеќе од еден филозоф.
2. Блокада: состојба во која секој филозоф чека друг филозоф да ослободи вилушка.
3. Изгладнување: барем еден филозоф не успеал да ги земе двете вилушки.
4. Последователност: најголемиот број на филозофи кои јадат истовремено е 1.

Најважни методи во оваа класа се методите `eat()` и `think()` кои се повикуваат во `execute()` методот на `DiningPhilosophers.Philosopher` класата:

- `eat()` методот го имплементира процесот на јадење. Прво се забележува дека филозофот преминал во состојба „јадење“. Се проверува дали некој од соседите на овој филозоф тековно јаде, и во таков случај се забележува исклучок, бидејќи дошло до појава на настан 1. Се зголемува бројот на филозофи кои тековно јадат и нишката се суспендира одредено време со што е овозможено извршување друга нишка. Филозофот завршува со јадење кога тековната нишка ќе продолжи да се извршува, истиот се враќа во состојба „размислување“ и бројот на филозофи кои тековно јадат се намалува за еден. Се напоменува дека состојбата „размислување“ во овој контекст претставува комплемент на состојбата „јадење“, т.е. филозоф во состојба „размислување“ може да не размислува, туку да чека вилушка за одновно да почне да јаде. Едно извршување на eat() методот е аналогно на конзумирање оброк.
- `think()` методот забележува дека филозофот преминал во состојба „размислување“ и ја суспендира нишката.

`clear()` методот го враќа `DiningPhilosophersState` објектот во првобитната состојба што овозможува ново извршување на решението. `finalize()` методот врши проверка за појава на настан 3 и 4 од листата. Нема потреба од посебна проверка за појава на настанот 2 бидејќи самата извршна околина го детектира. Поради начинот на забележување на исклучоците, при случување на блокада се бележи дека се случило изгладнување иако станува збор за вистинска блокада која е препознаена. Овој проблем може да се заобиколи доколку се коментира линијата код `throw e;` во `logException()` методот на `AbstractState` класата – во таков случај, се забележува грешка изгладнување и грешка блокада.

4. Користени извори
------------
<sub>1. https://www.cs.utexas.edu/users/EWD/transcriptions/EWD06xx/EWD625.html, Second solution. 14.09.2014</sub><br />
<sub>2. http://www.cs.utexas.edu/~EWD/transcriptions/EWD03xx/EWD310.html. 14.09.2014</sub><br />
<sub>3. Allen B. Downey, The Little Book Of Semaphores, Version 2.1.5, p. 103, 104</sub>